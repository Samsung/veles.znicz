#!/usr/bin/python3.3 -O
"""
Created on Dec 20, 2013.

@author: Podoynitsina Lyubov <lyubov.p@samsung.com>
"""

import sys
import os

def add_path(path):
    if path not in sys.path:
        sys.path.append(path)

this_dir = os.path.dirname(__file__)
if not this_dir:
    this_dir = "."
add_path("%s" % (this_dir))
add_path("%s/../.." % (this_dir))
add_path("%s/../../../src" % (this_dir))
add_path(".:../..:../../../src:../../../libSoundFeatureExtraction/python")


import units
import logging
import numpy
import audio_file_loader
import snd_features
import argparse
import workflow
from sound_feature_extraction.features_xml import FeaturesXml
import pickle


class Workflow(workflow.Workflow):
    """Workflow.
    """
    def __init__(self):
        super(Workflow, self).__init__()

        self.audio_loader = audio_file_loader.AudioFileLoader()
        self.audio_loader.link_from(self.start_point)

        self.extr = snd_features.SoundFeatures(None)
        self.extr.link_from(self.audio_loader)
        self.extr.inputs = self.audio_loader.outputs

        self.forward = Forward()
        self.forward.ff = self.extr
        self.forward.ff_key = "outputs"
        self.forward.link_from(self.extr)

        self.end_point.link_from(self.forward)

    def initialize(self, file, feature_file, W, b,
                   window_size, shift_size):
        self.audio_loader.files_list = [file]
        self.forward.W = W
        self.forward.b = b
        self.forward.window_size = window_size
        self.forward.shift_size = shift_size
        features = FeaturesXml.parse(feature_file)
        self.extr.add_features(features)
        return self.start_point.initialize_dependent()


class Forward(units.Unit):

    def __init__(self, ff=None, W=None, b=None, window_size=None,
                 shift_size=None):
        super(Forward, self).__init__()
        self.W = W
        self.b = b
        self.window_size = window_size
        self.ff = ff
        self.shift_size = shift_size
        self.outs = None

    def run(self):

        ff = self.ff.__dict__[self.ff_key]
        ff = ff[0][0]

        labels = {"blues": 0,
                  "country": 1,
                  "jazz": 2,
                  "pop": 3,
                  "rock": 4,
                  "classical": 5,
                  "disco": 6,
                  "hiphop": 7,
                  "metal": 8,
                  "reggae": 9}
        i_labels = {}
        for k, v in labels.items():
            i_labels[v] = k
        features = ["Energy", "Centroid", "Flux", "Rolloff", "ZeroCrossings"]
        norm_add = {'Rolloff': (-4194.1299697454906),
                    'Centroid': (-2029.2262731600895),
                    'ZeroCrossings': (-55.22063408843276),
                    'Flux': (-0.91969949785961735),
                    'Energy': (-10533446.715802385)}

        norm_mul = {'Rolloff': 0.00016505214530598153,
                    'Centroid': 0.00014461928085116515,
                    'ZeroCrossings': 0.0025266602711760356,
                    'Flux': 0.066174680046850856,
                    'Energy': 3.2792848460441024e-09}

        inp = numpy.zeros(len(features) * self.window_size,
                          dtype=numpy.float64)
        self.outs = numpy.zeros(len(labels), dtype=numpy.float64)
        self.outs_index = numpy.zeros(len(labels), dtype=numpy.float64)
        window_offs = 0
        eod = False
        while not eod:
            jj = 0
            offs2 = window_offs + self.window_size
            for k in features:
                v = ff[k]
                if window_offs + self.window_size > len(v):
                    eod = True
                    break
                j = jj
                jj = j + self.window_size
                inp[j:jj] = v[window_offs:offs2]
                inp[j:jj] += norm_add[k]
                inp[j:jj] *= norm_mul[k]
            if eod:
                break
            window_offs += self.shift_size
            if inp.min() < -1.0001:
                logging.info("input is out of range: %.6f" % (inp.min()))
            if inp.max() > 1.0001:
                logging.info("input is out of range: %.6f" % (inp.max()))
            a = inp
            for i in range(len(self.W) - 1):
                weights = self.W[i]
                bias = self.b[i]
                out = numpy.dot(a, weights.transpose())
                out += bias
                out *= 0.6666
                numpy.tanh(out, out)
                out *= 1.7159
                a = out
            i = len(self.W) - 1
            weights = self.W[i]
            bias = self.b[i]
            out = numpy.dot(a, weights.transpose())
            out += bias
            # Apply softmax
            m = out.max()
            out -= m
            numpy.exp(out, out)
            smm = out.sum()
            out /= smm
            # Sum totals
            self.outs += out
            logging.info("Out: %s" % (out))
        logging.info("Out_final: %s" % (self.outs))
        #self.outs_index = self.outs
        self.outs_index = self.outs.argsort()
        genre = i_labels[self.outs_index[9]]
        procent = self.outs[self.outs_index[9]]
        logging.info("Best genre: %s (%s)" % (genre, procent))
        logging.info("Best 3 genre: %s (%s), %s (%s), %s (%s)" % \
                             (i_labels[self.outs_index[9]], \
                              self.outs[self.outs_index[9]], \
                              i_labels[self.outs_index[8]], \
                              self.outs[self.outs_index[8]], \
                              i_labels[self.outs_index[7]], \
                              self.outs[self.outs_index[7]]))


def main():
    #if __debug__:
    #    logging.basicConfig(level=logging.DEBUG)
    #else:
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser()
    parser.add_argument("-window_size", type=float,
        help="Window size (default 100)", default=100)
    parser.add_argument("-shift_size", type=float,
        help="Shift size", default=50)
    parser.add_argument("-f", "--features", dest="features",
                        help="name of the file with feature "
                        "descriptions [default: %(default)s]",
                        metavar="path", required=True)
    parser.add_argument("-file", type=str, required=True, help="File name")
    parser.add_argument("-snapshot", type=str, required=True,
        help="Snapshot with trained weights and bias.")
    args = parser.parse_args()

    fin = open(args.snapshot, "rb")
    W, b = pickle.load(fin)
    fin.close()

    w = Workflow()
    w.initialize(file=args.file, feature_file=args.features,
                 W=W, b=b, window_size=args.window_size,
                 shift_size=args.shift_size)
    w.run()

if __name__ == "__main__":
    main()
    sys.exit(0)
