#!/usr/bin/python3 -O
# encoding: utf-8
"""
Created on June 29, 2013


Model created for Chinese characters recognition. Dataset was generated by
VELES with generate_kanji.py utility.
Model â€“ fully-connected Neural Network with MSE loss function.

Copyright (c) 2013 Samsung Electronics Co., Ltd.
"""


import logging

from veles.config import root
from veles.znicz.samples.kanji import KanjiLoader
from veles.znicz.standard_workflow import StandardWorkflow


class KanjiWorkflow(StandardWorkflow):
    def __init__(self, workflow, **kwargs):
        super(KanjiWorkflow, self).__init__(
            workflow, **kwargs)

    def create_workflow(self):
        # Add repeater unit
        self.link_repeater(self.start_point)

        # Add loader unit
        self.link_loader(self.repeater)

        # Add fwds units
        self.link_forwards(self.loader, ("input", "minibatch_data"))

        # Add evaluator for single minibatch
        self.link_evaluator(self.forwards[-1])

        # Add decision unit
        self.link_decision(self.evaluator)

        # Add snapshotter unit
        self.link_snapshotter(self.decision)

        # Add gradient descent units
        self.link_gds(self.snapshotter)

        if root.kanji_standard.add_plotters:
            # Add plotters units
            self.link_error_plotter(self.gds[0])
            self.link_weights_plotter(
                self.error_plotter[-1], layers=root.kanji_standard.layers,
                limit=root.kanji_standard.weights_plotter.limit,
                weights_input="weights")
            self.link_max_plotter(self.weights_plotter[-1])
            self.link_min_plotter(self.max_plotter[-1])
            self.link_mse_plotter(self.min_plotter[-1])
            last = self.mse_plotter[-1]
        else:
            last = self.gds[0]

        # Add end point unit
        self.link_end_point(last)

    def initialize(self, device, weights, bias, **kwargs):
        super(KanjiWorkflow, self).initialize(device=device)
        if weights is not None:
            for i, fwds in enumerate(self.forwards):
                fwds.weights.map_invalidate()
                fwds.weights.mem[:] = weights[i][:]
        if bias is not None:
            for i, fwds in enumerate(self.forwards):
                fwds.bias.map_invalidate()
                fwds.bias.mem[:] = bias[i][:]

    def link_loader(self, init_unit):
        self.loader = KanjiLoader(
            self, validation_ratio=root.kanji_standard.loader.validation_ratio,
            train_path=root.kanji_standard.data_paths.train,
            target_path=root.kanji_standard.data_paths.target,
            minibatch_size=root.kanji_standard.loader.minibatch_size)
        self.loader.link_from(init_unit)


def run(load, main):
    weights = None
    bias = None
    w, snapshot = load(
        KanjiWorkflow,
        fail_iterations=root.kanji_standard.decision.fail_iterations,
        max_epochs=root.kanji_standard.decision.max_epochs,
        prefix=root.kanji_standard.snapshotter.prefix,
        snapshot_dir=root.common.snapshot_dir,
        layers=root.kanji_standard.layers,
        loss_function=root.kanji_standard.loss_function)
    if snapshot:
        if type(w) == tuple:
            logging.info("Will load weights")
            weights = w[0]
            bias = w[1]
        else:
            logging.info("Will load workflow")
            logging.info("Weights and bias ranges per layer are:")
            for fwds in w.fwds:
                logging.info("%f %f %f %f" % (
                    fwds.weights.mem.min(), fwds.weights.mem.max(),
                    fwds.bias.mem.min(), fwds.bias.mem.max()))
            w.decision.improved <<= True
    main(weights=weights, bias=bias)
